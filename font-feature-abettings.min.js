(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
 * Font Feature Abettings 0.1.0
 * Collect glyph names from a font’s OpenType gsub data.
 * http://kennethormandy.com
 * Copyright © 2014 Kenneth Ormandy. Available under the MIT License.
 */

// Pass in gsub
// Pass in gnames

module.exports = function(gsub, gnames) {

  var item;
  var feat;
  var ft;
  var patterns = {};
  var permitted = ['liga', 'dlig', 'lnum']; // Options
  var figures = ['pnum', 'onum', 'lnum', 'tnum'];
  var iterate;

  /**
   * Flatten gsub, wizardry by @sintaxi
   */
  iterate = function(node, prefix) {
    var arr = [];

    // Nothing to do
    if (Object.prototype.toString.call(node) !== '[object Object]') {
      return prefix || [];
    }

    // Inception
    for (var key in node) {
      arr.push(iterate(gnames[node[key]], (prefix || '') + gnames[key]));
    }

    // Flatten
    return [].concat.apply([], arr);
  };

  /**
   * Flatten gsub table into feature names
   *
   */
  for(feat in gsub) {
    if(gsub.hasOwnProperty(feat)) {
      if(figures.indexOf(feat) !== -1) {
        // Regex and FAR need to happen separately
        // so this can be a Regex instead of…this thing:
        patterns[feat] = ',0,1,2,3,4,5,6,7,8,9';
      } else if(permitted.indexOf(feat) !== -1) {
        patterns[feat] = '';
        for(item in gsub[feat]) {
          var gsubPortion = gsub[feat][item];
          // It seems like this should all be part of @sintaxi’s thing, too
          if(gsub[feat].hasOwnProperty(item)) {
            // if(gsubPortion.length === 1) {
            //   console.log(gnames[gsubPortion[0]]);
            // } else
            if(Object.prototype.toString.call(gsubPortion) === '[object Object]') {
              patterns[feat] += ',' + (iterate(gsubPortion, '' + gnames[item]));
            }
            // else {
            //   // If it’s not an object, it’s a single character substitution
            //   return patterns += ',' + iterate(gsub[feat]).join());
            // }
          }
        }
      }
    }
  }

  /**
   * Return flattened features
   *
   */
  return patterns;
};

},{}]},{},[1]);
